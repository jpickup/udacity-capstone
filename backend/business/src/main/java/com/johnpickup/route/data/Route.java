package com.johnpickup.route.data;

import com.amazonaws.services.dynamodbv2.datamodeling.*;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.johnpickup.route.util.Haversine;
import lombok.Builder;
import lombok.Setter;
import lombok.ToString;

import java.util.List;
import java.util.Optional;

import lombok.extern.jackson.Jacksonized;
import org.springframework.data.annotation.Id;

@Setter
@ToString
@Builder
@Jacksonized
@JsonIgnoreProperties(ignoreUnknown = true)
@DynamoDBTable(tableName = "Route")
public class Route {
    public Route() {}

    public Route(String id, Visibility visibility, String name, String description, List<RoutePoint> points, String owner) {
        this.id = id;
        this.visibility = visibility;
        this.name = name;
        this.description = description;
        this.points = points;
        this.owner = owner;
    }

    @Id
    private String id;
    private Visibility visibility;
    private String name;
    private String description;
    private List<RoutePoint> points;
    private String owner;

    @DynamoDBHashKey
    @DynamoDBAutoGeneratedKey
    public String getId() {
        return id;
    }

    @DynamoDBAttribute
    @DynamoDBTypeConvertedEnum
    public Visibility getVisibility() {
        return visibility;
    }

    @DynamoDBAttribute
    public String getName() {
        return name;
    }

    @DynamoDBAttribute
    public String getDescription() {
        return description;
    }

    @DynamoDBAttribute
    @DynamoDBTypeConverted(converter = RoutePoint.RoutePointsConverter.class)
    public List<RoutePoint> getPoints() {
        return points;
    }

    @DynamoDBAttribute
    public String getOwner() {
        return owner;
    }

    @JsonProperty
    public LatLon centre() {
        BoundingLatLon bounds = bounds();
        return LatLon.builder()
                .longitude((bounds.getMinLongitude() + bounds.getMaxLongitude())/2)
                .latitude((bounds.getMinLatitude() + bounds.getMaxLatitude())/2)
                .build();
    }

    @JsonProperty
    public BoundingLatLon bounds() {
        double minLatitude = points.stream().map(RoutePoint::getLatitude).min(Double::compare).orElse(0d);
        double maxLatitude = points.stream().map(RoutePoint::getLatitude).max(Double::compare).orElse(0d);
        double minLongitude = points.stream().map(RoutePoint::getLongitude).min(Double::compare).orElse(0d);
        double maxLongitude = points.stream().map(RoutePoint::getLongitude).max(Double::compare).orElse(0d);
        double latitudePad = (maxLatitude - minLatitude) / 10d;
        double longitudePad = (maxLongitude - minLongitude) / 10d;

        return BoundingLatLon.builder()
                .maxLatitude(maxLatitude + latitudePad)
                .minLatitude(minLatitude - latitudePad)
                .maxLongitude(maxLongitude + longitudePad)
                .minLongitude(minLongitude - longitudePad)
                .build();
    }

    @JsonProperty
    public LatLon startPoint() {
        return points.stream()
                .findFirst()
                .map(p -> LatLon.builder().latitude(p.getLatitude()).longitude(p.getLongitude()).build())
                .orElse(null);
    }

    @JsonProperty
    public LatLon endPoint() {
        return points.stream()
                .reduce((a,b) -> b)
                .map(p -> LatLon.builder().latitude(p.getLatitude()).longitude(p.getLongitude()).build())
                .orElse(null);
    }

    @JsonProperty
    public double length() {
        double result = 0d;
        RoutePoint previous = null;
        for (RoutePoint point : points) {
            if (previous != null) {
                result += Haversine.distanceDegrees(previous.getLatitude(), previous.getLongitude(), point.getLatitude(), point.getLongitude());
            }
            previous = point;
        }
        return result;
    }

    @JsonProperty
    public Double totalAscent() {
        Double result = null;
        RoutePoint previous = null;
        for (RoutePoint point : points) {
            if (point.getElevation() != null) {
                if (previous != null) {
                    if (point.getElevation() > previous.getElevation()) {
                        result = Optional.ofNullable(result).orElse(0d) + (point.getElevation() - previous.getElevation());
                    }
                }
                previous = point;
            }
        }
        return result;
    }

    @JsonProperty
    public Double totalDescent() {
        Double result = null;
        RoutePoint previous = null;
        for (RoutePoint point : points) {
            if (point.getElevation() != null) {
                if (previous != null) {
                    if (point.getElevation() < previous.getElevation()) {
                        result = Optional.ofNullable(result).orElse(0d) + (previous.getElevation() - point.getElevation());
                    }
                }
                previous = point;
            }
        }
        return result;
    }
}